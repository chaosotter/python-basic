from .. import exception

class Value(object):
    """Base class of all scalar values.
    
    These values are generated by the evaluation of expression.Expression
    objects.
    """

    # These type constants are used by statement.StatementAssignment and
    # expression.EFn.
    INT    = 1
    FLOAT  = 2
    STRING = 3
    NULL   = 4

    def __init__(self, value):
        """Initializes with some arbitrary bit of data."""
        self.value = value
    
    def Type(self):
        """Returns the type of this value (INT, etc.)."""
        return self.NULL

    def IsInt(self):
        """Checks if this is an integer value."""
        return False
        
    def IsFloat(self):
        """Checks if this is a floating-point value."""
        return False

    def IsNumeric(self):
        """Checks if this is a numeric value."""
        return self.IsInt() or self.IsFloat()

    def IsString(self):
        """Checks if this is a string value."""
        return False

    def __str__(self):
        """Returns a string representation of this value."""
        return str(self.value)

    def AsInt(self):
        """Returns this value as an actual Python integer."""
        raise exception.EvalException(exception.Error.ERR_TYPE)
        
    def AsFloat(self):
        """Returns this value as an actual Python float."""
        raise exception.EvalException(exception.Error.ERR_TYPE)

    def AsString(self):
        """Returns this value as an actual Python string."""
        raise exception.EvalException(exception.Error.ERR_TYPE)

    def RequireRange(self, min_value, max_value):
        """Requires this value to lie within a range to avoid an exception.
        
        Args:
            min_value (int or float): The minimum value (inclusive).
            max_value (int or float): The maximum value (inclusive).

        Raises:
            runtime.EvalException if the value is out of range or not of a
            numeric type.
        """
        if not self.IsNumeric():
            raise runtime.EvalException(runtime.Error.ERR_TYPE)
        if self.AsFloat() < min_value or self.AsFloat() > max_value:
            raise runtime.EvalException(runtime.Error.ERR_RANGE)
